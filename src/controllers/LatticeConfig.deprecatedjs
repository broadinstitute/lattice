import { Plot } from "./Plot";
import { LATTICE_DEFAULT_PADDING } from "../utils/constants";
import * as d3 from "d3";

export class LatticeConfig {
    /**
     * 
     * @param {Array[Object]} plots - Specifies the configuration for each individual plot. Expected attributes are:
     *                              - row
     *                              - column
     *                              - Plot object attributes (excluding rootId and parentId)
     * @param {String} rootId - div ID that the SVG should be created in
     * @param {Object} UNNAMED - contains all optional parameters
     *          {String} parentId - div ID that the plot should be created in, if the SVG already exists
     *          {Number} width - outer width of lattice plot
     *          {Number} height - outer height of lattice plot
     *          {Object} grid - attr: {Int} rows, {Int} columns -- can be used to specify the number of rows and columns
     *                                {Array[Object]} rowSizes -- can be used to customize size of each row
     *                                                            attr: {Int} row,
     *                                                                  {Float} size - Decimal between [0, 1]
     *                                {Array[Object]} columnSizes -- can be used to customize size of each column
     *                                                               attr: {Int} row,
     *                                                                    {Float} size - Decimal between [0, 1]
     *          {String} title - title of plot
     *          {Object} padding - attr: top, right, bottom, left; padding to apply around the chart
     */
    constructor(plots, rootId, {
        parentId=undefined, width=1000, height=600,
        grid={rows: undefined, columns: undefined, rowSizes: undefined, columnSizes: undefined},
        title=undefined,
        padding={top:LATTICE_DEFAULT_PADDING, right:LATTICE_DEFAULT_PADDING, bottom:LATTICE_DEFAULT_PADDING, left:LATTICE_DEFAULT_PADDING}
    }={}) {        
        this.rootId = rootId;
        this.parentId = parentId;
        this.padding = {
            // explicitly check in case user only specified one of the 4 padding values -- these can't be undefined
            top: padding.top === undefined ? LATTICE_DEFAULT_PADDING : padding.top,
            right: padding.right === undefined ? LATTICE_DEFAULT_PADDING : padding.right,
            bottom: padding.bottom === undefined ? LATTICE_DEFAULT_PADDING : padding.bottom,
            left: padding.left === undefined ? LATTICE_DEFAULT_PADDING : padding.left
        };
        this.width = width;
        this.height = height;
        this.innerWidth = width - this.padding.left - this.padding.right;
        this.innerHeight = height - this.padding.top - this.padding.bottom;
        this.title = title;
        this.grid = {
            rows: grid.rows ? grid.rows : d3.max(plots.map((x) => x.row)) + 1,
            columns : grid.columns ? grid.columns: d3.max(plots.map((x) => x.column)) + 1,
            rowSizes: grid.rowSizes,
            columnSizes: grid.columnSizes,
            plotSizes: undefined // will be calculated in a private function
        };
        this._validateGridInfo();
        this._updateGridInfo();
        const plotWidth = this.innerWidth / this.grid.columns;
        const plotHeight = this.innerHeight / this.grid.rows;
        this.plots = plots.map(d => {
            const plotConfig = new Plot(d.data, d.type, rootId, {
                width: this.innerWidth * this.grid.plotSizes[d.row][d.column].colSize,
                height: this.innerHeight * this.grid.plotSizes[d.row][d.column].rowSize,
                padding: d.padding,
                orientation: d.orientation,
                title: d.title,
                axis: d.axis,
                xScale: d.xScale,
                yScale: d.yScale,
                series: d.series,
                tooltip: d.tooltip
            });
            plotConfig.row = d.row;
            plotConfig.column = d.column;
            plotConfig.rowStart = this.grid.plotSizes[d.row][d.column].rowStart;
            plotConfig.colStart = this.grid.plotSizes[d.row][d.column].colStart;
            return plotConfig;
        }, this);
        this._createLatticeScales();
    }

    _createLatticeScales() {
        this.xScale = d3.scaleLinear().domain([0, 1]).range([0, this.innerWidth]);
        this.yScale = d3.scaleLinear().domain([0, 1]).range([0, this.innerHeight]);
    }

    /**
     * Private function.
     * Called by the constructor to validate that:
     * - ALL rows are customized if passed in by user
     * - ALL columns are customized if passed in by user
     * - that the customized percentages add up to 1 (100%)
     * If no customizations were made, calculates the needed grid information for generating lattice grid
     */
    _validateGridInfo() {
        if (this.grid.rowSizes !== undefined) {
            if (this.grid.rows !== this.grid.rowSizes.length) {
                console.error("Must specify size of every row when customizing the lattice grid.");
                throw "Must specify size of every row when customizing the lattice grid.";
            }

            const rowGridTotal = this.grid.rowSizes.reduce((a, b) => a + b.size, 0);
            if (Number(rowGridTotal.toPrecision(2)) != 1) {
                console.error("In rowSizes, sum of all size values must add up to 1.");
                throw "In rowSizes, sum of all size values must add up to 1.";
            }
        } else {
            this.grid.rowSizes = [];
            for (let i = 0; i < this.grid.rows; i++) {
                this.grid.rowSizes.push({ row: i, size: 1/this.grid.rows });
            }
        }

        if (this.grid.columnSizes !== undefined) {
            if (this.grid.columns !== this.grid.columnSizes.length) {
                console.log("Must specify size of every column when customizing the lattice grid.");
                throw "Must specify size of every column when customizing the lattice grid.";
            }

            const colGridTotal = this.grid.columnSizes.reduce((a, b) => a + b.size, 0);
            if (Number(colGridTotal.toPrecision(2)) != 1) {
                console.error("In columnSizes, sum of all size values must add up to 1.");
                throw "In columnSizes, sum of all size values must add up to 1.";
            }
        } else {
            this.grid.columnSizes = [];
            for (let i = 0; i < this.grid.columns; i++) {
                this.grid.columnSizes.push({ column: i, size: 1/this.grid.columns });
            }
        }
    }

    /**
     * Private function.
     * Calculates where each plot in the grid should start, as well as the relative height/width of each plot within the grid
     */
    _updateGridInfo() {
        this.grid.rowSizes.sort((a, b) => a.row - b.row);
        this.grid.columnSizes.sort((a, b) => a.column - b.column);
        this.grid.rowSizes.forEach((d, i) => {
            if (i == 0) {
                d.start = 0;
            } else {
                const prev = this.grid.rowSizes[i-1];
                d.start = prev.start + prev.size;
            }
        });
        this.grid.columnSizes.forEach((d, i) => {
            if (i == 0) {
                d.start = 0;
            } else {
                const prev = this.grid.columnSizes[i-1];
                d.start = prev.start + prev.size;
            }
        });

        this.grid.plotSizes = this.grid.rowSizes.map(i => {
            return this.grid.columnSizes.map(j => {
                return {
                    rowSize: i.size,
                    rowStart: i.start,
                    colSize: j.size,
                    colStart: j.start
                };
            });
        });
    }
}
